<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Scientific logbook (Posts about jupyter)</title><link>https://laurentperrinet.github.io/sciblog/</link><description></description><atom:link href="https://laurentperrinet.github.io/sciblog/categories/jupyter.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2022 &lt;a href="mailto:laurent.perrinet@univ-amu.fr"&gt;Laurent Perrinet&lt;/a&gt; 
&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/ar/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="http://i.creativecommons.org/l/by-nc-sa/2.5/ar/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Mon, 20 Jun 2022 11:07:57 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Experimenting with transfer learning for visual categorization</title><link>https://laurentperrinet.github.io/sciblog/posts/2021-04-28-experimenting-with-transfer-learning-for-visual-categorization.html</link><dc:creator>Laurent Perrinet</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;a href="https://zenodo.org/badge/latestdoi/362495685"&gt;&lt;img src="https://zenodo.org/badge/362495685.svg" alt="DOI"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi! I am  &lt;a href="https://laurentperrinet.github.io/author/jean-nicolas-jeremie/"&gt;Jean-Nicolas Jérémie&lt;/a&gt; and the goal of this notebook is to provide a framework to implement (and experiment with) &lt;a href="https://en.wikipedia.org/wiki/Transfer_learning"&gt;transfer learning&lt;/a&gt; on deep convolutional neuronal network (DCNN). In a nutshell, &lt;a href="https://www.analyticsvidhya.com/blog/2021/06/transfer-learning-using-vgg16-in-pytorch/"&gt;transfer learning&lt;/a&gt; allows to re-use the knowlegde learned on a problem, such as categorizing images from  a large dataset, and apply it to a different (yet related) problem, performing the categorization on a smaller dataset. It is a powerful method as it allows to implement complex task &lt;em&gt;de novo&lt;/em&gt; quite rapidly (in a few hours) without having to retrain the millions of parameters of a DCNN (which takes days of computations). The basic hypothesis is that it suffices to &lt;a href="https://www.kaggle.com/carloalbertobarbano/vgg16-transfer-learning-pytorch"&gt;re-train the last classification layers&lt;/a&gt; (the head) while keeping the first layers fixed. Here, these networks teach us also some interesting insights into how living systems may perform such categorization tasks.&lt;/p&gt;
&lt;p&gt;Based on our &lt;a href="https://laurentperrinet.github.io/sciblog/posts/2020-09-28-benchmarking-cnns.html"&gt;previous work&lt;/a&gt;, we will start from a &lt;a href="https://pytorch.org/hub/pytorch_vision_vgg/"&gt;VGG16 network&lt;/a&gt; loaded from the &lt;a href="https://github.com/pytorch/vision/blob/main/torchvision/models/vgg.py"&gt;&lt;code&gt;torchvision.models&lt;/code&gt; library&lt;/a&gt; and pre-trained on the &lt;a href="http://image-net.org/"&gt;Imagenet&lt;/a&gt; dataset wich allows to perform label detection on naturals images for $K = 1000$ labels. Our goal here will be to re-train the last fully-Connected layer of the network to perfom the same task but in a sub-set of $K = 10$ labels from the Imagenet dataset.&lt;/p&gt;
&lt;p&gt;Moreover, we are going to evaluate different strategies of transfer learning:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VGG General : Substitute the last layer of the pyTorch VGG16 network ($K = 1000$ labels) with a new layer build from a specific subset ($K = 10$ labels).&lt;/li&gt;
&lt;li&gt;VGG Linear : Add a new layer build from a specific subset ($K = 10$ labels) after the last Fully-Connected layer of the the pyTorch VGG16 network.&lt;/li&gt;
&lt;li&gt;VGG Gray : Same architecture as the VGG General network but trained with grayscale images.&lt;/li&gt;
&lt;li&gt;VGG Scale : Same architecture as the VGG General network but trained with images of different size.&lt;/li&gt;
&lt;li&gt;VGG Full : Same architecture as the VGG General network but all the layers are trained (otherwise I trained the last Fully-Connected layer). &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this notebook, I will use the &lt;a href="https://pytorch.org/"&gt;pyTorch&lt;/a&gt; library for running the networks and the &lt;a href="https://pandas.pydata.org/docs/getting_started/index.html"&gt;pandas&lt;/a&gt; library to collect and display the results. This notebook was done during a master 2 internship at the Neurosciences Institute of Timone (INT) under the supervision of &lt;a href="https://laurentperrinet.github.io/"&gt;Laurent Perrinet&lt;/a&gt;. It is curated in the following &lt;a href="https://github.com/JNJER/2021-04-28_transfer_learning"&gt;github repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://laurentperrinet.github.io/sciblog/posts/2021-04-28-experimenting-with-transfer-learning-for-visual-categorization.html"&gt;Read more…&lt;/a&gt; (78 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>computational neuroscience</category><category>deep-learning</category><category>jupyter</category><category>learning</category><category>machine-learning</category><category>open-science</category><category>pandas</category><category>python</category><category>pytorch</category><category>vision</category><guid>https://laurentperrinet.github.io/sciblog/posts/2021-04-28-experimenting-with-transfer-learning-for-visual-categorization.html</guid><pubDate>Fri, 03 Dec 2021 15:23:51 GMT</pubDate></item><item><title>Benchmarking CNNs</title><link>https://laurentperrinet.github.io/sciblog/posts/2020-09-28-benchmarking-cnns.html</link><dc:creator>Laurent Perrinet</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Hi! I am  &lt;a href="https://github.com/JNJER"&gt;Jean-Nicolas Jérémie&lt;/a&gt; and the goal of this benchmark is to offer a comparison between differents pre-trained image recognition's networks based on the &lt;a href="http://image-net.org/"&gt;Imagenet&lt;/a&gt; dataset wich allows to work on naturals images for $1000$ labels. These different networks tested here are taken from the &lt;code&gt;torchvision.models&lt;/code&gt; library : &lt;code&gt;AlexNet&lt;/code&gt;, &lt;code&gt;VGG16&lt;/code&gt;, &lt;code&gt;MobileNetV2&lt;/code&gt; and &lt;code&gt;ResNet101&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our use case is to measure the performance of a system which receives a sequence of images and has to make a decision as soon as possible, hence with &lt;code&gt;batch_size=1&lt;/code&gt;. Specifically, we wish also to compare different computing architectures such as CPUs, desktop GPUs or other more exotic platform such as the Jetson TX2 (experiment 1). Additionally, we will implement some image transformations as up/down-sampling (experiment 2) or transforming to grayscale (experiment 3) to quantify their influence on the accuracy and computation time of each network.&lt;/p&gt;
&lt;p&gt;In this notebook, I will use the &lt;a href="https://pytorch.org/"&gt;Pytorch&lt;/a&gt; library for running the networks and the &lt;a href="https://pandas.pydata.org/docs/getting_started/index.html"&gt;pandas&lt;/a&gt; library to collect and display the results. This notebook was done during a master 1 internship at the Neurosciences Institute of Timone (INT) under the supervision of &lt;a href="https://laurentperrinet.github.io/"&gt;Laurent PERRINET&lt;/a&gt;. It is curated in the following &lt;a href="https://github.com/JNJER/2020-06-26_fast_and_curious"&gt;github repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://laurentperrinet.github.io/sciblog/posts/2020-09-28-benchmarking-cnns.html"&gt;Read more…&lt;/a&gt; (35 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>computational neuroscience</category><category>deep-learning</category><category>jupyter</category><category>machine-learning</category><category>math</category><category>open-science</category><category>pandas</category><category>pytorch</category><guid>https://laurentperrinet.github.io/sciblog/posts/2020-09-28-benchmarking-cnns.html</guid><pubDate>Mon, 28 Sep 2020 15:25:57 GMT</pubDate></item><item><title>nesting jupyter runs</title><link>https://laurentperrinet.github.io/sciblog/posts/2020-08-09-nesting-jupyter-runs.html</link><dc:creator>Laurent Perrinet</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;a href="https://jupyter.org/"&gt;Jupyter notebooks&lt;/a&gt; are a great way of sharing knowledge in science, art, programming. 
For instance, in a recent musing, I tried to programmatically determine the &lt;a href="https://laurentperrinet.github.io/sciblog/posts/2020-07-04-colors-of-the-sky.html"&gt;color of the sky&lt;/a&gt;. This renders as a web page, but is also a piece of &lt;a href="https://laurentperrinet.github.io/sciblog/posts/2020-07-04-colors-of-the-sky.ipynb"&gt;runnable code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As such, they are also great ways to store the knowledge that was acquired at a given time and that could be reusable. This may be considered as bad programming and may have downsides as described in that &lt;a href="https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/edit#slide=id.g362da58057_0_1"&gt;slides&lt;/a&gt; :&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/edit#slide=id.g362da58057_0_1"&gt;&lt;img src="https://revolution-computing.typepad.com/.a/6a010534b1db25970b022ad3b0836c200b-800wi" alt="Joel Grus"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Recently, thanks to an answer to a &lt;a href="https://stackoverflow.com/questions/48067529/ipython-run-magic-n-switch-not-working"&gt;stack overflow question&lt;/a&gt;,  I found a way to overcome this by detecting if the caall to a notebook is made from the notebook itself or from a parent.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://laurentperrinet.github.io/sciblog/posts/2020-08-09-nesting-jupyter-runs.html"&gt;Read more…&lt;/a&gt; (1861 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>ipython</category><category>jupyter</category><category>open-science</category><guid>https://laurentperrinet.github.io/sciblog/posts/2020-08-09-nesting-jupyter-runs.html</guid><pubDate>Sun, 09 Aug 2020 08:52:18 GMT</pubDate></item></channel></rss>